var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _OneSecMailbox_instances, _OneSecMailbox_api, _OneSecMailbox_local, _OneSecMailbox_domain, _OneSecMailbox_controller, _OneSecMailbox_state, _OneSecMailbox_lastMessageid, _OneSecMailbox_intervalTimer, _OneSecMailbox_polling, _OneSecMailShortMessage_api, _OneSecMailShortMessage_local, _OneSecMailShortMessage_domain, _OneSecMailShortMessage_emailAddress, _OneSecMailAttachment_api, _OneSecMailAttachment_local, _OneSecMailAttachment_domain, _OneSecMailAttachment_messageId;
import { got } from "got";
import { z } from "zod";
import { TypedEmitter } from "tiny-typed-emitter";
import OneSecMailAPI, { BASE_API_URL, FORBIDDEN_LOGIN } from "./OneSecMailAPI.js";
import { shortMessageSchema } from "./schemas.js";
export default async function OneSecMail(a, b) {
    let emailAddress = null;
    let options = {};
    if (typeof a === "string" && typeof b === "undefined") {
        emailAddress = a;
    }
    else if (typeof a === "object" && typeof b === "undefined") {
        options = a;
    }
    else if (typeof a === "string" && typeof b === "object") {
        emailAddress = a;
        options = b;
    }
    const api = new OneSecMailAPI(options);
    if (!emailAddress) {
        [emailAddress] = await api.genRandomMailbox();
        return new OneSecMailbox(emailAddress, api);
    }
    const schema = z.string().email();
    if (!schema.safeParse(emailAddress).success) {
        throw new Error("Email address must be a valid email address");
    }
    const [local, domain] = emailAddress.toLowerCase().split("@");
    if (FORBIDDEN_LOGIN.includes(local)) {
        throw new Error(`For security reason you cannot read messages from addresses: ${FORBIDDEN_LOGIN.map((local) => `${local}@${domain}`).join(", ")}`);
    }
    const domainList = await api.getDomainList();
    if (!domainList.includes(domain)) {
        throw new Error(`Email address must contain a domain contained in the following list: ${domainList
            .map((domain) => `${local}@${domain}`)
            .join(", ")}`);
    }
    return new OneSecMailbox(`${local}@${domain}`, api);
}
class OneSecMailbox extends TypedEmitter {
    constructor(emailAddress, api) {
        super();
        _OneSecMailbox_instances.add(this);
        _OneSecMailbox_api.set(this, void 0);
        _OneSecMailbox_local.set(this, void 0);
        _OneSecMailbox_domain.set(this, void 0);
        _OneSecMailbox_controller.set(this, void 0);
        _OneSecMailbox_state.set(this, "STOPPED");
        _OneSecMailbox_lastMessageid.set(this, 0);
        _OneSecMailbox_intervalTimer.set(this, void 0);
        const [local, domain] = emailAddress.split("@");
        __classPrivateFieldSet(this, _OneSecMailbox_api, api, "f");
        __classPrivateFieldSet(this, _OneSecMailbox_local, local, "f");
        __classPrivateFieldSet(this, _OneSecMailbox_domain, domain, "f");
        __classPrivateFieldSet(this, _OneSecMailbox_controller, new AbortController(), "f");
        this.emailAddress = emailAddress;
    }
    async getMessages(options) {
        const messages = await __classPrivateFieldGet(this, _OneSecMailbox_api, "f").getMessages(__classPrivateFieldGet(this, _OneSecMailbox_local, "f"), __classPrivateFieldGet(this, _OneSecMailbox_domain, "f"), options);
        return messages.map((message) => {
            return new OneSecMailShortMessage(this.emailAddress, message, __classPrivateFieldGet(this, _OneSecMailbox_api, "f"));
        });
    }
    async clearMessages(options) {
        try {
            await got.post("https://www.1secmail.com/mailbox", {
                form: {
                    action: "deleteMailbox",
                    login: __classPrivateFieldGet(this, _OneSecMailbox_local, "f"),
                    domain: __classPrivateFieldGet(this, _OneSecMailbox_domain, "f"),
                },
                retry: {
                    limit: options?.retry ?? __classPrivateFieldGet(this, _OneSecMailbox_api, "f").retry,
                },
                timeout: {
                    request: options?.timeout ?? __classPrivateFieldGet(this, _OneSecMailbox_api, "f").timeout,
                },
            });
        }
        catch (e) {
            throw new Error("HTTP request failed");
        }
    }
    startPolling(intervalTime = 5000) {
        if (intervalTime < 1000)
            throw new RangeError("`intervalTime` must be at least 1000");
        if (__classPrivateFieldGet(this, _OneSecMailbox_state, "f") === "STARTED")
            return false;
        __classPrivateFieldGet(this, _OneSecMailbox_instances, "m", _OneSecMailbox_polling).call(this, intervalTime);
        __classPrivateFieldSet(this, _OneSecMailbox_state, "STARTED", "f");
        return true;
    }
    stopPolling() {
        if (__classPrivateFieldGet(this, _OneSecMailbox_state, "f") === "STOPPED")
            return false;
        __classPrivateFieldGet(this, _OneSecMailbox_controller, "f").abort();
        clearTimeout(__classPrivateFieldGet(this, _OneSecMailbox_intervalTimer, "f"));
        __classPrivateFieldSet(this, _OneSecMailbox_state, "STOPPED", "f");
        return true;
    }
}
_OneSecMailbox_api = new WeakMap(), _OneSecMailbox_local = new WeakMap(), _OneSecMailbox_domain = new WeakMap(), _OneSecMailbox_controller = new WeakMap(), _OneSecMailbox_state = new WeakMap(), _OneSecMailbox_lastMessageid = new WeakMap(), _OneSecMailbox_intervalTimer = new WeakMap(), _OneSecMailbox_instances = new WeakSet(), _OneSecMailbox_polling = async function _OneSecMailbox_polling(intervalTime) {
    const start = new Date().getTime();
    try {
        const { body } = await got.get(BASE_API_URL, {
            searchParams: { action: "getMessages", login: __classPrivateFieldGet(this, _OneSecMailbox_local, "f"), domain: __classPrivateFieldGet(this, _OneSecMailbox_domain, "f") },
            retry: { limit: 0 },
            timeout: { request: 3000 },
            signal: __classPrivateFieldGet(this, _OneSecMailbox_controller, "f").signal,
        });
        const schema = z.array(shortMessageSchema);
        let messages;
        try {
            messages = schema.parse(JSON.parse(body));
        }
        catch (e) {
            throw new Error("Malformed response");
        }
        messages.sort((a, b) => a.id - b.id);
        messages = messages.filter((message) => message.id > __classPrivateFieldGet(this, _OneSecMailbox_lastMessageid, "f"));
        __classPrivateFieldSet(this, _OneSecMailbox_lastMessageid, messages.at(-1)?.id ?? __classPrivateFieldGet(this, _OneSecMailbox_lastMessageid, "f"), "f");
        for (const message of messages) {
            this.emit("newMessage", new OneSecMailShortMessage(this.emailAddress, message, __classPrivateFieldGet(this, _OneSecMailbox_api, "f")));
        }
        const end = new Date().getTime();
        const diff = end - start;
        __classPrivateFieldSet(this, _OneSecMailbox_intervalTimer, setTimeout(__classPrivateFieldGet(this, _OneSecMailbox_instances, "m", _OneSecMailbox_polling).bind(this), intervalTime - diff, intervalTime), "f");
    }
    catch (error) {
        if (error instanceof Error && error.name !== "AbortError") {
            const end = new Date().getTime();
            const diff = end - start;
            __classPrivateFieldSet(this, _OneSecMailbox_intervalTimer, setTimeout(__classPrivateFieldGet(this, _OneSecMailbox_instances, "m", _OneSecMailbox_polling).bind(this), intervalTime - diff, intervalTime), "f");
            this.emit("error", error);
        }
    }
};
class OneSecMailShortMessage {
    constructor(emailAddress, message, api) {
        _OneSecMailShortMessage_api.set(this, void 0);
        _OneSecMailShortMessage_local.set(this, void 0);
        _OneSecMailShortMessage_domain.set(this, void 0);
        _OneSecMailShortMessage_emailAddress.set(this, void 0);
        const [local, domain] = emailAddress.split("@");
        __classPrivateFieldSet(this, _OneSecMailShortMessage_api, api, "f");
        __classPrivateFieldSet(this, _OneSecMailShortMessage_local, local, "f");
        __classPrivateFieldSet(this, _OneSecMailShortMessage_domain, domain, "f");
        __classPrivateFieldSet(this, _OneSecMailShortMessage_emailAddress, emailAddress, "f");
        this.id = message.id;
        this.from = message.from;
        this.subject = message.subject;
        this.date = message.date;
    }
    async fetchFullMessage(options) {
        const message = await __classPrivateFieldGet(this, _OneSecMailShortMessage_api, "f").readMessage(__classPrivateFieldGet(this, _OneSecMailShortMessage_local, "f"), __classPrivateFieldGet(this, _OneSecMailShortMessage_domain, "f"), this.id, options);
        if (!message)
            throw new Error("Message no longer exists");
        return new OneSecMailMessage(__classPrivateFieldGet(this, _OneSecMailShortMessage_emailAddress, "f"), message, __classPrivateFieldGet(this, _OneSecMailShortMessage_api, "f"));
    }
    serialize() {
        return {
            id: this.id,
            from: this.from,
            subject: this.subject,
            date: this.date,
        };
    }
}
_OneSecMailShortMessage_api = new WeakMap(), _OneSecMailShortMessage_local = new WeakMap(), _OneSecMailShortMessage_domain = new WeakMap(), _OneSecMailShortMessage_emailAddress = new WeakMap();
class OneSecMailMessage {
    constructor(emailAddress, message, api) {
        this.id = message.id;
        this.from = message.from;
        this.subject = message.subject;
        this.date = message.date;
        this.attachments = message.attachments.map((attachment) => {
            return new OneSecMailAttachment(emailAddress, message.id, attachment, api);
        });
        this.body = message.body;
        this.textBody = message.textBody;
        this.htmlBody = message.htmlBody;
    }
    serialize() {
        return {
            id: this.id,
            from: this.from,
            subject: this.subject,
            date: this.date,
            attachments: this.attachments.map((attachment) => attachment.serialize()),
            body: this.body,
            textBody: this.textBody,
            htmlBody: this.htmlBody,
        };
    }
}
class OneSecMailAttachment {
    constructor(emailAddress, messageId, attachment, api) {
        _OneSecMailAttachment_api.set(this, void 0);
        _OneSecMailAttachment_local.set(this, void 0);
        _OneSecMailAttachment_domain.set(this, void 0);
        _OneSecMailAttachment_messageId.set(this, void 0);
        const [local, domain] = emailAddress.split("@");
        __classPrivateFieldSet(this, _OneSecMailAttachment_api, api, "f");
        __classPrivateFieldSet(this, _OneSecMailAttachment_local, local, "f");
        __classPrivateFieldSet(this, _OneSecMailAttachment_domain, domain, "f");
        __classPrivateFieldSet(this, _OneSecMailAttachment_messageId, messageId, "f");
        this.filename = attachment.filename;
        this.contentType = attachment.contentType;
        this.size = attachment.size;
    }
    async download(options) {
        const file = await __classPrivateFieldGet(this, _OneSecMailAttachment_api, "f").download(__classPrivateFieldGet(this, _OneSecMailAttachment_local, "f"), __classPrivateFieldGet(this, _OneSecMailAttachment_domain, "f"), __classPrivateFieldGet(this, _OneSecMailAttachment_messageId, "f"), this.filename, options);
        if (!file)
            throw new Error("File no longer exists");
        return file;
    }
    serialize() {
        return {
            filename: this.filename,
            contentType: this.contentType,
            size: this.size,
        };
    }
}
_OneSecMailAttachment_api = new WeakMap(), _OneSecMailAttachment_local = new WeakMap(), _OneSecMailAttachment_domain = new WeakMap(), _OneSecMailAttachment_messageId = new WeakMap();
